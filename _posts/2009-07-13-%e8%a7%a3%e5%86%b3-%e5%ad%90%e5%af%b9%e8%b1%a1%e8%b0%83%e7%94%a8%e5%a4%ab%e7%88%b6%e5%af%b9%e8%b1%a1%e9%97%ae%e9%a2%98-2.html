---
layout: post
title: 解决-子对象调用夫父对象问题
date: 2009-07-13 18:56:00.000000000 +08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Programming
tags: []
meta:
  blogger_5db691c6560366c0233000029746f2a2_permalink: '1297782982785625967'
  blogger_author: yangyilong
  blogger_blog: everydaydreamy.blogspot.com
author:
  login: mcloud
  email: ''
  display_name: mcloud
  first_name: ''
  last_name: ''
---
<p>当软件写的很大时候，就出现了这个问题，<br />1.解决子对象调用夫父对象调用问题（单级-多级）<span style="color:#ff0000;">--this指针</span><br />单级：<br />a.父对象可以直接使用子对象(耦合)<br />b.子对象要使用夫对象传入this指针（内容耦合)<br />多级:<br />a.父对象无法直接调用子对象<br />b.子对象可以通过多个this指针调用夫对象</p>
<p>解决：自己猜想<br />1.使用依赖注入DI(解耦）<br />在同一个测试类中，将子类多个也可以注入到父类中，这样就可以使用任何一<br />个类<br />2.使用反射机制 （配置文件)<br />得到当前类的所有实例（不行，除非在调用类中定义一个list,注入到每个类<br />中，构造方法，set方法都可以 ）,调用时从list找出对应对象，然后就可以调<br />用了，（慢）查阅资料后使用map这样可以觉得慢的问题<br />3.使用克隆技术 （不行)</p>
<p>最后综合一下,使用IOC=DI,比工厂模式进一步解耦，如果在程序中完成注入这样耦合比较大，使用配置文件，使用反射机制，动态注入，这样耦合更小</p>
<p>要调用每个对象，使用MAP保存即可</p>
<p>总结：IOC+反射+XML+MAP可以完美的解决这个问题</p>
<p>现在可以编写一个这样的框架，但是工作量比较大，spring 完美的解决了这个问题，所以接下来学习spring即可</p>
<p>也可以说<span style="color:#ff0000;">spring(IOC) = DJ + 反射 + xml + map </span></p>
<p><span style="color:#ff0000;"><span style="color:#000000;">转一个比较好的比喻</span></span></p>
<p><!--[if gte mso 9]&gt;  Normal 0  7.8 磅 0 2  false false false               MicrosoftInternetExplorer4  &lt;![endif]--><!--[if gte mso 9]&gt;   &lt;![endif]--><!--  /* Font Definitions */  @font-face 	{font-family:宋体; 	panose-1:2 1 6 0 3 1 1 1 1 1; 	mso-font-alt:SimSun; 	mso-font-charset:134; 	mso-generic-font-family:auto; 	mso-font-pitch:variable; 	mso-font-signature:3 135135232 16 0 262145 0;} @font-face 	{font-family:"@宋体"; 	panose-1:2 1 6 0 3 1 1 1 1 1; 	mso-font-charset:134; 	mso-generic-font-family:auto; 	mso-font-pitch:variable; 	mso-font-signature:3 135135232 16 0 262145 0;}  /* Style Definitions */  p.MsoNormal, li.MsoNormal, div.MsoNormal 	{mso-style-parent:""; 	margin:0cm; 	margin-bottom:.0001pt; 	text-align:justify; 	text-justify:inter-ideograph; 	mso-pagination:none; 	font-size:10.5pt; 	mso-bidi-font-size:12.0pt; 	font-family:"Times New Roman"; 	mso-fareast-font-family:宋体; 	mso-font-kerning:1.0pt;}  /* Page Definitions */  @page 	{mso-page-border-surround-header:no; 	mso-page-border-surround-footer:no;} @page Section1 	{size:612.0pt 792.0pt; 	margin:72.0pt 90.0pt 72.0pt 90.0pt; 	mso-header-margin:36.0pt; 	mso-footer-margin:36.0pt; 	mso-paper-source:0;} div.Section1 	{page:Section1;} --><!--[if gte mso 10]&gt; &lt;!   /* Style Definitions */  table.MsoNormalTable 	{mso-style-name:普通表格; 	mso-tstyle-rowband-size:0; 	mso-tstyle-colband-size:0; 	mso-style-noshow:yes; 	mso-style-parent:&quot;&quot;; 	mso-padding-alt:0cm 5.4pt 0cm 5.4pt; 	mso-para-margin:0cm; 	mso-para-margin-bottom:.0001pt; 	mso-pagination:widow-orphan; 	font-size:10.0pt; 	font-family:&quot;Times New Roman&quot;; 	mso-fareast-font-family:&quot;Times New Roman&quot;; 	mso-ansi-language:#0400; 	mso-fareast-language:#0400; 	mso-bidi-language:#0400;} --> <!--[endif]--><span style="font-size:12pt;font-family:宋体;">　<span style="font-size:small;">　<span lang="EN-US">(1)</span>原始社会里，几乎没有社会分工。需要斧子的人<span lang="EN-US">(</span>调用者<span lang="EN-US">)</span>只能自己去磨一把斧子<span lang="EN-US">(</span>被调用者<span lang="EN-US">)</span>。对应的情形为<span lang="EN-US">:Java</span>程序里的调用者自己创建被调用者。</span></span></p>
<p>　　<span lang="EN-US">(2)</span>进入工业社会，工厂出现。斧子不再由普通人完成，而在工厂里被生产出来，此时需要斧子的人<span lang="EN-US">(</span>调用者<span lang="EN-US">)</span>找到工厂，购买斧子，无须关心斧子的制造过程。对应<span lang="EN-US">Java</span>程序的简单工厂的设计模式。</p>
<p>　　<span lang="EN-US">(3)</span>进入<span lang="EN-US">“</span>按需分配<span lang="EN-US">”</span>社会，需要斧子的人不需要找到工厂，坐在家里发出一个简单指令<span lang="EN-US">:</span>需要斧子。斧子就自然出现在他面前。对应<span lang="EN-US">Spring</span>的依赖注入。</p>
<p>　　第一种情况下，<span lang="EN-US">Java</span>实例的调用者创建被调用的<span lang="EN-US">Java</span>实例，必然要求被调用的<span lang="EN-US">Java</span>类出现在调用者的代码里。无法实现二者之间的松耦合。</p>
<p>　　第二种情况下，调用者无须关心被调用者具体实现过程，只需要找到符合某种标准<span lang="EN-US">(</span>接口<span lang="EN-US">)</span>的实例，即可使用。此时调用的代码面向接口编程，可以让调用者和被调用者解耦，这也是工厂模式大量使用的原因。但调用者需要自己定位工厂，调用者与特定工厂耦合在一起。</p>
<p>　　第三种情况下，调用者无须自己定位工厂，程序运行到需要被调用者时，系统自动提供被调用者实例。事实上，调用者和被调用者都处于<span lang="EN-US">Spring</span>的管理下，二者之间的依赖关系由<span lang="EN-US">Spring</span>提供。
<div class="blogger-post-footer"><img width="1" height="1" src="{{ site.baseurl }}/assets/" alt="" /></div>
